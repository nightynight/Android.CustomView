{
  "name": "Android.customview",
  "tagline": "",
  "body": "####自定义View的步骤：\r\n1、自定义View的属性\r\n2、在View的构造方法中获得我们自定义的属性\r\n[ 3、重写onMesure ]\r\n4、重写onDraw\r\n####下面分别介绍每一步骤\r\n####1、自定义View的属性，首先在res/values/  下建立一个attrs.xml ， 在里面定义我们的属性和声明我们的整个样式。\r\n```\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<resources>\r\n    <attr name=\"myTitleText\" format=\"string\" />\r\n    <attr name=\"myTitleTextColor\" format=\"color\" />\r\n    <attr name=\"myTitleTextSize\" format=\"dimension\" />\r\n    <declare-styleable name=\"CustomTitleView\">\r\n        <attr name=\"myTitleText\" />\r\n        <attr name=\"myTitleTextColor\" />\r\n        <attr name=\"myTitleTextSize\" />\r\n    </declare-styleable>\r\n</resources>\r\n```\r\n我们定义了字体，字体颜色，字体大小3个属性，format是值该属性的取值类型:\r\n一共有：string,color,demension,integer,enum,reference,float,boolean,fraction,flag;不清楚的可以google一把。\r\n然后在布局中声明我们的自定义View\r\n```\r\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    xmlns:custom=\"http://schemas.android.com/apk/res-auto\">\r\n    <com.brokepal.customviewdemo.view.CustomTitleView\r\n        android:id=\"@+id/myView\"\r\n        android:layout_width=\"200dp\"\r\n        android:layout_height=\"100dp\"\r\n        custom:myTitleText=\"3712\"\r\n        custom:myTitleTextColor=\"#ff0000\"\r\n        custom:myTitleTextSize=\"40sp\" />\r\n</RelativeLayout>\r\n```\r\n####2、在View的构造方法中，获得我们的自定义的样式\r\n```\r\npublic class CustomTitleView extends View {\r\n    private String mTitleText;\r\n    private int mTitleTextColor;\r\n    private int mTitleTextSize;\r\n    /**\r\n     * 绘制时控制文本绘制的范围\r\n     */\r\n    private Rect mBound;\r\n    private Paint mPaint;\r\n    public CustomTitleView(Context context, AttributeSet attrs)\r\n    {\r\n        this(context, attrs, 0);\r\n    }\r\n    public CustomTitleView(Context context)\r\n    {\r\n        this(context, null);\r\n    }\r\n    /**\r\n     * 构造函数，获取属性列表，设置监听器\r\n     *\r\n     * @param context\r\n     * @param attrs\r\n     * @param defStyle\r\n     */\r\n    public CustomTitleView(Context context, AttributeSet attrs, int defStyle)\r\n    {\r\n        super(context, attrs, defStyle);\r\n        /**\r\n         * 获得我们所定义的自定义样式属性\r\n         */\r\n        TypedArray a = context.getTheme().obtainStyledAttributes(attrs, R.styleable.CustomTitleView, defStyle, 0);\r\n        int n = a.getIndexCount();\r\n        for (int i = 0; i < n; i++)\r\n        {\r\n            int attr = a.getIndex(i);\r\n            switch (attr)\r\n            {\r\n                case R.styleable.CustomTitleView_myTitleText:\r\n                    mTitleText = a.getString(attr);\r\n                    break;\r\n                case R.styleable.CustomTitleView_myTitleTextColor:\r\n                    // 默认颜色设置为黑色\r\n                    mTitleTextColor = a.getColor(attr, Color.BLACK);\r\n                    break;\r\n                case R.styleable.CustomTitleView_myTitleTextSize:\r\n                    // 默认设置为16sp，TypeValue也可以把sp转化为px\r\n                    mTitleTextSize = a.getDimensionPixelSize(attr, (int) TypedValue.applyDimension(\r\n                            TypedValue.COMPLEX_UNIT_SP, 16, getResources().getDisplayMetrics()));\r\n                    break;\r\n            }\r\n        }\r\n        /**\r\n         * 获得绘制文本的宽和高\r\n         */\r\n        mPaint = new Paint();\r\n        mPaint.setTextSize(mTitleTextSize);\r\n        mBound = new Rect();\r\n        mPaint.getTextBounds(mTitleText, 0, mTitleText.length(), mBound);\r\n    }\r\n}\r\n```\r\n####3、重写onMesure、onDraw方法\r\n```\r\n@Override\r\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)\r\n{\r\n    super.onMeasure(widthMeasureSpec, heightMeasureSpec);  \r\n}\r\n@Override\r\nprotected void onDraw(Canvas canvas)\r\n{\r\n    mPaint.setColor(Color.YELLOW);\r\n    canvas.drawRect(0, 0, getMeasuredWidth(), getMeasuredHeight(), mPaint);\r\n    mPaint.setColor(mTitleTextColor);\r\n    canvas.drawText(mTitleText, getWidth() / 2 - mBound.width() / 2, getHeight() / 2 + mBound.height() / 2, mPaint);\r\n}\r\n```\r\n此时的效果是：\r\n\r\n但是此时如果我们把布局文件的宽和高写成wrap_content，会发现效果并不是我们的预期：\r\n\r\n系统帮我们测量的高度和宽度都是MATCH_PARNET，当我们设置明确的宽度和高度时，系统帮我们测量的结果就是我们设置的结果，当我们设置为WRAP_CONTENT,或者MATCH_PARENT系统帮我们测量的结果就是MATCH_PARENT的长度。所以，当设置了WRAP_CONTENT时，我们需要自己进行测量，即重写onMesure方法”。\r\n####重写之前先了解MeasureSpec的specMode,一共三种类型：\r\nEXACTLY：一般是设置了明确的值或者是MATCH_PARENT\r\nAT_MOST：表示子布局限制在一个最大值内，一般为WARP_CONTENT\r\nUNSPECIFIED：表示子布局想要多大就多大，很少使用\r\n下面是我们重写onMeasure代码：\r\n```\r\n@Override\r\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)\r\n{\r\n    int widthMode = MeasureSpec.getMode(widthMeasureSpec);\r\n    int widthSize = MeasureSpec.getSize(widthMeasureSpec);\r\n    int heightMode = MeasureSpec.getMode(heightMeasureSpec);\r\n    int heightSize = MeasureSpec.getSize(heightMeasureSpec);\r\n    int width;\r\n    int height ;\r\n    /*\r\n    MeasureSpec的specMode,一共三种类型：\r\n        EXACTLY：一般是设置了明确的值或者是MATCH_PARENT\r\n        AT_MOST：表示子布局限制在一个最大值内，一般为WARP_CONTENT\r\n        UNSPECIFIED：表示子布局想要多大就多大，很少使用\r\n    */\r\n    if (widthMode == MeasureSpec.EXACTLY)\r\n    {\r\n        width = widthSize;\r\n    } else\r\n    {\r\n        mPaint.setTextSize(mTitleTextSize);\r\n        mPaint.getTextBounds(mTitleText, 0, mTitleText.length(), mBound);\r\n        float textWidth = mBound.width();\r\n        int desired = (int) (getPaddingLeft() + textWidth + getPaddingRight());\r\n        width = desired;\r\n    }\r\n    if (heightMode == MeasureSpec.EXACTLY)\r\n    {\r\n        height = heightSize;\r\n    } else\r\n    {\r\n        mPaint.setTextSize(mTitleTextSize);\r\n        mPaint.getTextBounds(mTitleText, 0, mTitleText.length(), mBound);\r\n        float textHeight = mBound.height();\r\n        int desired = (int) (getPaddingTop() + textHeight + getPaddingBottom());\r\n        height = desired;\r\n    }\r\n    //设置控件的宽高\r\n    setMeasuredDimension(width, height);\r\n}\r\n```\r\n现在我们修改下布局文件：\r\n```\r\n<com.brokepal.customviewdemo.view.CustomTitleView\r\n    android:id=\"@+id/myView\"\r\n    android:layout_width=\"wrap_content\"\r\n    android:layout_height=\"wrap_content\"\r\n    android:padding=\"10dp\"\r\n    android:layout_centerInParent=\"true\"\r\n    custom:myTitleText=\"3712\"\r\n    custom:myTitleTextColor=\"#ff0000\"\r\n    custom:myTitleTextSize=\"40sp\" />\r\n```\r\n现在的效果是：\r\n\r\n现在我们可以对高度、宽度进行随便的设置了，基本可以满足我们的需求。\r\n接下来，给我们的控件添加一个监听器，让我们的控件实现点击后产生随机数的功能。\r\n在构造函数中添加：\r\n```\r\n//设置监听器\r\nthis.setOnClickListener(new OnClickListener() {\r\n    @Override\r\n    public void onClick(View v)\r\n    {\r\n        mTitleText = randomText();\r\n        postInvalidate();   //刷新页面，会再次执行onMeasure方法和onDraw方法\r\n    }\r\n});\r\n```\r\n下面为randomText函数：\r\n```\r\n//获取随机字符串\r\nprivate String randomText()\r\n{\r\n    Random random = new Random();\r\n    Set<Integer> set = new HashSet<Integer>();\r\n    while (set.size() < 4)\r\n    {\r\n        int randomInt = random.nextInt(10);\r\n        set.add(randomInt);\r\n    }\r\n    StringBuffer sb = new StringBuffer();\r\n    for (Integer i : set)\r\n    {\r\n        sb.append(\"\" + i);\r\n    }\r\n    return sb.toString();\r\n}\r\n```\r\n接下来为控件的属性设置get、set方法，使之可以在activity中修改样式。\r\n```\r\n//给mTitleText设置set方法，一般会设置所有属性的get、set方法，这里就不多设置了\r\npublic void setmTitleText(String text){\r\n    mTitleText=text;\r\n    invalidate();   //mTitleText改变之后要重新绘制控件\r\n}\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}